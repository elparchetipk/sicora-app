#!/usr/bin/env python3
"""
Extractor Mejorado de Contenido de Soporte para KBService
Enfocado espec√≠ficamente en extraer informaci√≥n √∫til para soporte primario 
de usuarios sobre c√≥mo interactuar con los diferentes m√≥dulos de SICORA.
"""

import os
import re
import json
import sys
from pathlib import Path
from typing import List, Dict, Any, Optional, Set
from datetime import datetime
import markdown
from bs4 import BeautifulSoup


class SupportKnowledgeExtractor:
    """Extractor especializado en informaci√≥n de soporte para usuarios."""
    
    def __init__(self, base_path: str):
        self.base_path = Path(base_path)
        
        # Patrones espec√≠ficos para identificar informaci√≥n de soporte
        self.support_patterns = {
            'how_to': [
                r'como\s+.*?(?:hacer|usar|acceder|configurar|gestionar)',
                r'pasos\s+para',
                r'procedimiento\s+para',
                r'instrucciones\s+para',
                r'gu√≠a\s+para'
            ],
            'troubleshooting': [
                r'problema.*?soluci√≥n',
                r'error.*?resoluci√≥n',
                r'no\s+funciona',
                r'fallo.*?correcci√≥n',
                r'troubleshooting'
            ],
            'faq': [
                r'pregunta.*?frecuente',
                r'qu√©\s+es',
                r'c√≥mo\s+se',
                r'cu√°ndo\s+se',
                r'por\s+qu√©',
                r'FAQ'
            ],
            'user_interface': [
                r'pantalla\s+de',
                r'interfaz\s+de',
                r'formulario\s+de',
                r'ventana\s+de',
                r'bot√≥n\s+de',
                r'men√∫\s+de'
            ],
            'workflows': [
                r'flujo\s+de\s+trabajo',
                r'proceso\s+de',
                r'secuencia\s+de',
                r'workflow',
                r'procedimiento\s+est√°ndar'
            ]
        }
        
        # M√≥dulos de SICORA para categorizaci√≥n
        self.sicora_modules = {
            'attendanceservice': {
                'name': 'Asiste (Control de Asistencia)',
                'keywords': ['asistencia', 'tardanza', 'falta', 'excusa', 'presencia'],
                'user_actions': [
                    'marcar asistencia',
                    'consultar historial de asistencia',
                    'registrar tardanza',
                    'justificar falta',
                    'revisar pol√≠tica de asistencia'
                ]
            },
            'scheduleservice': {
                'name': 'Horarios (Gesti√≥n de Horarios y Ambientes)',
                'keywords': ['horario', 'ambiente', 'aula', 'programaci√≥n', 'calendario'],
                'user_actions': [
                    'consultar horario personal',
                    'ver disponibilidad de ambientes',
                    'programar clases',
                    'modificar horarios',
                    'gestionar ambientes de formaci√≥n'
                ]
            },
            'evalinservice': {
                'name': 'Evaluaci√≥n de Instructores',
                'keywords': ['evaluaci√≥n', 'instructor', 'desempe√±o', 'calificaci√≥n'],
                'user_actions': [
                    'evaluar instructor',
                    'consultar resultados de evaluaci√≥n',
                    'participar en evaluaci√≥n docente',
                    'revisar criterios de evaluaci√≥n'
                ]
            },
            'mevalservice': {
                'name': 'Comit√© (Gesti√≥n de Comit√©s Acad√©micos)',
                'keywords': ['comit√©', 'reuni√≥n', 'decisi√≥n', 'acad√©mico', 'evaluaci√≥n'],
                'user_actions': [
                    'participar en comit√©',
                    'consultar actas de comit√©',
                    'programar reuniones',
                    'revisar decisiones acad√©micas'
                ]
            },
            'projectevalservice': {
                'name': 'Evaluaci√≥n de Proyectos',
                'keywords': ['proyecto', 'evaluaci√≥n', 'formativo', 'pr√°ctica'],
                'user_actions': [
                    'evaluar proyecto formativo',
                    'consultar criterios de evaluaci√≥n',
                    'revisar proyectos asignados',
                    'calificar entregables'
                ]
            },
            'userservice': {
                'name': 'Gesti√≥n de Usuarios',
                'keywords': ['usuario', 'perfil', 'cuenta', 'autenticaci√≥n', 'sesi√≥n'],
                'user_actions': [
                    'iniciar sesi√≥n',
                    'cambiar contrase√±a',
                    'actualizar perfil',
                    'recuperar contrase√±a',
                    'gestionar roles'
                ]
            },
            'kbservice': {
                'name': 'Base de Conocimiento',
                'keywords': ['ayuda', 'documentaci√≥n', 'soporte', 'FAQ', 'tutorial'],
                'user_actions': [
                    'buscar informaci√≥n',
                    'acceder a tutoriales',
                    'consultar FAQs',
                    'obtener ayuda',
                    'reportar problemas'
                ]
            }
        }
        
        # Tipos de usuarios con necesidades espec√≠ficas
        self.user_profiles = {
            'aprendices': {
                'needs': [
                    'procedimientos b√°sicos',
                    'acceso a funciones estudiantiles',
                    'consulta de informaci√≥n personal',
                    'cumplimiento de requisitos',
                    'resoluci√≥n de problemas comunes'
                ],
                'priority_modules': ['attendanceservice', 'scheduleservice', 'userservice', 'evalinservice']
            },
            'instructores': {
                'needs': [
                    'gesti√≥n de clases',
                    'evaluaci√≥n de estudiantes',
                    'administraci√≥n de horarios',
                    'generaci√≥n de reportes',
                    'uso de herramientas pedag√≥gicas'
                ],
                'priority_modules': ['scheduleservice', 'attendanceservice', 'evalinservice', 'projectevalservice']
            },
            'administrativos': {
                'needs': [
                    'supervisi√≥n de procesos',
                    'generaci√≥n de reportes',
                    'gesti√≥n de usuarios',
                    'configuraci√≥n del sistema',
                    'resoluci√≥n de incidencias'
                ],
                'priority_modules': ['userservice', 'mevalservice', 'scheduleservice', 'kbservice']
            }
        }
    
    def extract_support_content(self) -> List[Dict[str, Any]]:
        """Extraer contenido espec√≠fico de soporte de usuarios."""
        
        print("üîç Iniciando extracci√≥n de contenido de soporte...")
        
        # Buscar archivos de documentaci√≥n
        rf_files = list(self.base_path.glob("**/rf*.md"))
        story_files = list(self.base_path.glob("**/historias*.md"))
        
        print(f"üìÑ Encontrados {len(rf_files)} archivos de requisitos funcionales")
        print(f"üìö Encontrados {len(story_files)} archivos de historias de usuario")
        
        support_items = []
        
        # Procesar requisitos funcionales
        for rf_file in rf_files:
            items = self._extract_from_requirements(rf_file)
            support_items.extend(items)
            
        # Procesar historias de usuario
        for story_file in story_files:
            items = self._extract_from_stories(story_file)
            support_items.extend(items)
        
        # Post-procesar y enriquecer
        enriched_items = self._enrich_support_content(support_items)
        
        print(f"‚úÖ Extra√≠dos {len(enriched_items)} elementos de soporte")
        return enriched_items
    
    def _extract_from_requirements(self, file_path: Path) -> List[Dict[str, Any]]:
        """Extraer informaci√≥n de soporte de requisitos funcionales."""
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
        except Exception as e:
            print(f"‚ùå Error leyendo {file_path}: {e}")
            return []
        
        items = []
        
        # Determinar m√≥dulo por nombre de archivo
        module = self._identify_module(file_path.name)
        
        # Buscar secciones de funcionalidades
        sections = self._extract_functional_sections(content)
        
        for section in sections:
            # Extraer informaci√≥n espec√≠fica de soporte
            support_info = self._extract_support_info(section, module)
            if support_info:
                support_info['source_file'] = str(file_path.relative_to(self.base_path))
                support_info['source_type'] = 'requirements'
                items.append(support_info)
        
        return items
    
    def _extract_from_stories(self, file_path: Path) -> List[Dict[str, Any]]:
        """Extraer informaci√≥n de soporte de historias de usuario."""
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
        except Exception as e:
            print(f"‚ùå Error leyendo {file_path}: {e}")
            return []
        
        items = []
        
        # Determinar m√≥dulo y tipo de frontend/backend
        module = self._identify_module(file_path.name)
        ui_type = 'frontend' if 'fe' in file_path.name else 'backend'
        
        # Extraer historias individuales
        stories = self._extract_user_stories(content)
        
        for story in stories:
            # Convertir historia en informaci√≥n de soporte
            support_info = self._story_to_support(story, module, ui_type)
            if support_info:
                support_info['source_file'] = str(file_path.relative_to(self.base_path))
                support_info['source_type'] = 'user_story'
                items.append(support_info)
        
        return items
    
    def _identify_module(self, filename: str) -> str:
        """Identificar el m√≥dulo de SICORA basado en el nombre del archivo."""
        
        filename_lower = filename.lower()
        
        for module_key in self.sicora_modules.keys():
            if module_key in filename_lower:
                return module_key
        
        # Mapeos adicionales
        module_mappings = {
            'asiste': 'attendanceservice',
            'horario': 'scheduleservice',
            'evalin': 'evalinservice',
            'comite': 'mevalservice',
            'proyecto': 'projectevalservice',
            'user': 'userservice',
            'kb': 'kbservice'
        }
        
        for key, module in module_mappings.items():
            if key in filename_lower:
                return module
        
        return 'general'
    
    def _extract_functional_sections(self, content: str) -> List[Dict[str, Any]]:
        """Extraer secciones funcionales de un documento."""
        
        sections = []
        
        # Dividir por encabezados
        lines = content.split('\n')
        current_section = None
        current_content = []
        
        for line in lines:
            # Detectar encabezados
            if re.match(r'^#+\s+', line):
                # Guardar secci√≥n anterior si existe
                if current_section and current_content:
                    sections.append({
                        'title': current_section,
                        'content': '\n'.join(current_content),
                        'level': len(re.match(r'^(#+)', line).group(1))
                    })
                
                # Iniciar nueva secci√≥n
                current_section = re.sub(r'^#+\s+', '', line).strip()
                current_content = []
            else:
                current_content.append(line)
        
        # Agregar √∫ltima secci√≥n
        if current_section and current_content:
            sections.append({
                'title': current_section,
                'content': '\n'.join(current_content),
                'level': len(re.match(r'^(#+)', current_section).group(1)) if re.match(r'^#+', current_section) else 2
            })
        
        return sections
    
    def _extract_user_stories(self, content: str) -> List[Dict[str, Any]]:
        """Extraer historias de usuario individuales."""
        
        stories = []
        
        # Patr√≥n para historias de usuario
        story_pattern = r'\*\*HU-.*?\*\*:?\s*(.*?)(?=\*\*HU-|\*\*Como|\Z)'
        
        matches = re.finditer(story_pattern, content, re.DOTALL | re.IGNORECASE)
        
        for match in matches:
            story_content = match.group(1).strip()
            
            # Extraer componentes de la historia
            story_data = self._parse_user_story(story_content)
            if story_data:
                stories.append(story_data)
        
        return stories
    
    def _parse_user_story(self, content: str) -> Optional[Dict[str, Any]]:
        """Parsear una historia de usuario individual."""
        
        # Buscar patrones de historia de usuario
        como_match = re.search(r'\*\*Como\*\*\s+(.*?)(?:\n|\*\*)', content, re.IGNORECASE)
        quiero_match = re.search(r'\*\*Quiero\*\*\s+(.*?)(?:\n|\*\*)', content, re.IGNORECASE)
        para_match = re.search(r'\*\*Para\*\*\s+(.*?)(?:\n|\*\*)', content, re.IGNORECASE)
        
        if not (como_match and quiero_match and para_match):
            return None
        
        return {
            'role': como_match.group(1).strip(),
            'action': quiero_match.group(1).strip(),
            'benefit': para_match.group(1).strip(),
            'full_content': content
        }
    
    def _extract_support_info(self, section: Dict[str, Any], module: str) -> Optional[Dict[str, Any]]:
        """Extraer informaci√≥n espec√≠fica de soporte de una secci√≥n."""
        
        content = section['content']
        title = section['title']
        
        # Verificar si la secci√≥n contiene informaci√≥n de soporte
        support_score = 0
        support_type = None
        
        for pattern_type, patterns in self.support_patterns.items():
            for pattern in patterns:
                if re.search(pattern, content, re.IGNORECASE):
                    support_score += 1
                    support_type = pattern_type
        
        if support_score == 0:
            return None
        
        # Extraer informaci√≥n √∫til
        return {
            'title': f"{self.sicora_modules.get(module, {}).get('name', module.upper())}: {title}",
            'content': content[:1000],  # Limitar contenido
            'support_type': support_type,
            'module': module,
            'target_users': self._identify_target_users(content),
            'keywords': self._extract_keywords(content, module),
            'priority': self._calculate_priority(content, module),
            'extracted_at': datetime.utcnow().isoformat()
        }
    
    def _story_to_support(self, story: Dict[str, Any], module: str, ui_type: str) -> Optional[Dict[str, Any]]:
        """Convertir una historia de usuario en informaci√≥n de soporte."""
        
        if not story.get('action'):
            return None
        
        # Crear t√≠tulo descriptivo
        title = f"C√≥mo {story['action']}"
        
        # Crear contenido de soporte
        content = f"""
**Objetivo:** {story['action']}

**Beneficio:** {story['benefit']}

**Tipo de usuario:** {story['role']}

**Interfaz:** {ui_type}

**Procedimiento:** Para {story['action']}, el usuario debe {story['benefit']}.
"""
        
        return {
            'title': title,
            'content': content,
            'support_type': 'procedure',
            'module': module,
            'ui_type': ui_type,
            'target_users': [self._normalize_user_role(story['role'])],
            'keywords': self._extract_keywords(story['action'], module),
            'priority': 'high' if any(keyword in story['action'].lower() for keyword in ['login', 'sesi√≥n', 'contrase√±a', 'asistencia']) else 'medium',
            'extracted_at': datetime.utcnow().isoformat()
        }
    
    def _identify_target_users(self, content: str) -> List[str]:
        """Identificar usuarios objetivo basado en el contenido."""
        
        users = []
        content_lower = content.lower()
        
        user_keywords = {
            'aprendices': ['aprendiz', 'estudiante', 'formaci√≥n', 'alumno'],
            'instructores': ['instructor', 'docente', 'profesor', 'facilitador'],
            'administrativos': ['admin', 'coordinador', 'director', 'administrativo']
        }
        
        for user_type, keywords in user_keywords.items():
            if any(keyword in content_lower for keyword in keywords):
                users.append(user_type)
        
        return users if users else ['general']
    
    def _normalize_user_role(self, role: str) -> str:
        """Normalizar rol de usuario."""
        
        role_lower = role.lower()
        
        if any(keyword in role_lower for keyword in ['aprendiz', 'estudiante', 'alumno']):
            return 'aprendices'
        elif any(keyword in role_lower for keyword in ['instructor', 'docente', 'profesor']):
            return 'instructores'
        elif any(keyword in role_lower for keyword in ['admin', 'coordinador', 'director']):
            return 'administrativos'
        else:
            return 'general'
    
    def _extract_keywords(self, content: str, module: str) -> List[str]:
        """Extraer palabras clave relevantes."""
        
        keywords = set()
        content_lower = content.lower()
        
        # Agregar palabras clave del m√≥dulo
        if module in self.sicora_modules:
            keywords.update(self.sicora_modules[module]['keywords'])
        
        # Extraer palabras clave t√©cnicas
        tech_keywords = [
            'login', 'sesi√≥n', 'contrase√±a', 'autenticaci√≥n',
            'horario', 'ambiente', 'aula', 'programaci√≥n',
            'asistencia', 'tardanza', 'falta', 'excusa',
            'evaluaci√≥n', 'calificaci√≥n', 'desempe√±o',
            'comit√©', 'reuni√≥n', 'acta', 'decisi√≥n',
            'proyecto', 'formativo', 'pr√°ctica', 'entregable',
            'usuario', 'perfil', 'cuenta', 'rol',
            'ayuda', 'soporte', 'documentaci√≥n', 'tutorial'
        ]
        
        for keyword in tech_keywords:
            if keyword in content_lower:
                keywords.add(keyword)
        
        return list(keywords)[:10]  # Limitar a 10 keywords
    
    def _calculate_priority(self, content: str, module: str) -> str:
        """Calcular prioridad basada en contenido y m√≥dulo."""
        
        content_lower = content.lower()
        
        # Alta prioridad para funciones cr√≠ticas
        high_priority_keywords = [
            'login', 'sesi√≥n', 'contrase√±a', 'autenticaci√≥n',
            'asistencia', 'tardanza', 'horario', 'evaluaci√≥n'
        ]
        
        if any(keyword in content_lower for keyword in high_priority_keywords):
            return 'high'
        
        # Prioridad media para m√≥dulos importantes
        if module in ['userservice', 'attendanceservice', 'scheduleservice']:
            return 'medium'
        
        return 'low'
    
    def _enrich_support_content(self, items: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Enriquecer contenido con informaci√≥n adicional."""
        
        enriched_items = []
        
        for item in items:
            # Agregar informaci√≥n del m√≥dulo
            module = item.get('module', 'general')
            if module in self.sicora_modules:
                module_info = self.sicora_modules[module]
                item['module_name'] = module_info['name']
                item['related_actions'] = module_info['user_actions']
            
            # Agregar tags mejorados
            item['tags'] = self._generate_enhanced_tags(item)
            
            # Agregar ID √∫nico
            item['id'] = self._generate_id(item)
            
            # Agregar categor√≠a
            item['category'] = module
            
            # Agregar estado
            item['status'] = 'published'
            
            enriched_items.append(item)
        
        return enriched_items
    
    def _generate_enhanced_tags(self, item: Dict[str, Any]) -> List[str]:
        """Generar tags mejorados para b√∫squeda."""
        
        tags = set()
        
        # Tags del m√≥dulo
        module = item.get('module', 'general')
        tags.add(module)
        
        # Tags de keywords
        keywords = item.get('keywords', [])
        tags.update(keywords)
        
        # Tags de tipo de soporte
        support_type = item.get('support_type')
        if support_type:
            tags.add(support_type)
        
        # Tags de usuarios objetivo
        target_users = item.get('target_users', [])
        tags.update(target_users)
        
        # Tags de UI
        ui_type = item.get('ui_type')
        if ui_type:
            tags.add(ui_type)
        
        return list(tags)[:15]  # Limitar tags
    
    def _generate_id(self, item: Dict[str, Any]) -> str:
        """Generar ID √∫nico para el item."""
        
        import hashlib
        
        content = f"{item.get('title', '')}{item.get('module', '')}{item.get('support_type', '')}"
        return hashlib.md5(content.encode()).hexdigest()[:12]
    
    def generate_support_statistics(self, items: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Generar estad√≠sticas del contenido de soporte."""
        
        stats = {
            'total_items': len(items),
            'by_module': {},
            'by_support_type': {},
            'by_target_user': {},
            'by_priority': {},
            'coverage_analysis': {}
        }
        
        for item in items:
            # Por m√≥dulo
            module = item.get('module', 'general')
            stats['by_module'][module] = stats['by_module'].get(module, 0) + 1
            
            # Por tipo de soporte
            support_type = item.get('support_type', 'other')
            stats['by_support_type'][support_type] = stats['by_support_type'].get(support_type, 0) + 1
            
            # Por usuario objetivo
            target_users = item.get('target_users', ['general'])
            for user in target_users:
                stats['by_target_user'][user] = stats['by_target_user'].get(user, 0) + 1
            
            # Por prioridad
            priority = item.get('priority', 'low')
            stats['by_priority'][priority] = stats['by_priority'].get(priority, 0) + 1
        
        # An√°lisis de cobertura
        for module, module_info in self.sicora_modules.items():
            module_items = stats['by_module'].get(module, 0)
            total_actions = len(module_info['user_actions'])
            coverage = (module_items / max(total_actions, 1)) * 100
            
            stats['coverage_analysis'][module] = {
                'items': module_items,
                'expected_actions': total_actions,
                'coverage_percentage': round(coverage, 2)
            }
        
        return stats


def main():
    """Funci√≥n principal."""
    
    print("üöÄ Extractor Mejorado de Contenido de Soporte para KBService")
    print("=" * 60)
    
    # Configurar rutas
    base_path = Path("/home/epti/Documentos/epti-dev/sicora-app")
    
    # Crear extractor
    extractor = SupportKnowledgeExtractor(str(base_path))
    
    # Extraer contenido
    support_items = extractor.extract_support_content()
    
    # Generar estad√≠sticas
    stats = extractor.generate_support_statistics(support_items)
    
    # Guardar resultados
    output_file = "enhanced_support_knowledge.json"
    stats_file = "support_statistics.json"
    
    with open(output_file, 'w', encoding='utf-8') as f:
        json.dump(support_items, f, ensure_ascii=False, indent=2)
    
    with open(stats_file, 'w', encoding='utf-8') as f:
        json.dump(stats, f, ensure_ascii=False, indent=2)
    
    print(f"\nüìä ESTAD√çSTICAS DE CONTENIDO DE SOPORTE")
    print(f"Total de elementos: {stats['total_items']}")
    print(f"\nüì± Por m√≥dulo:")
    for module, count in stats['by_module'].items():
        print(f"  {module}: {count} elementos")
    
    print(f"\nüõ†Ô∏è Por tipo de soporte:")
    for support_type, count in stats['by_support_type'].items():
        print(f"  {support_type}: {count} elementos")
    
    print(f"\nüë• Por usuario objetivo:")
    for user_type, count in stats['by_target_user'].items():
        print(f"  {user_type}: {count} elementos")
    
    print(f"\nüìà An√°lisis de cobertura:")
    for module, analysis in stats['coverage_analysis'].items():
        print(f"  {module}: {analysis['coverage_percentage']}% de cobertura ({analysis['items']}/{analysis['expected_actions']})")
    
    print(f"\nüíæ Resultados guardados en:")
    print(f"  üìÑ Contenido: {output_file}")
    print(f"  üìä Estad√≠sticas: {stats_file}")
    
    print(f"\n‚úÖ Extracci√≥n completada exitosamente!")


if __name__ == "__main__":
    main()
