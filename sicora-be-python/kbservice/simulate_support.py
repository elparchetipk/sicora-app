#!/usr/bin/env python3
"""
Simulador de consultas de soporte para KBService
Demuestra c√≥mo la base de conocimiento puede responder preguntas t√≠picas de usuarios.
"""

import json
import re
from typing import List, Dict, Any, Tuple
from pathlib import Path


class SupportQuerySimulator:
    """Simulador de consultas de soporte usando la base de conocimiento."""
    
    def __init__(self, knowledge_file: str):
        self.knowledge_items = []
        self.load_knowledge_base(knowledge_file)
        
        # Consultas t√≠picas por tipo de usuario
        self.sample_queries = {
            'aprendices': [
                "¬øC√≥mo puedo marcar mi asistencia?",
                "¬øQu√© pasa si llego tarde a clase?",
                "¬øC√≥mo cambio mi contrase√±a?",
                "¬øD√≥nde veo mis calificaciones?",
                "¬øC√≥mo puedo ver mi horario de clases?",
                "¬øQu√© hacer si olvido mi contrase√±a?",
                "¬øCu√°les son mis derechos como aprendiz?",
                "¬øQu√© sucede si falto muchos d√≠as?",
                "¬øC√≥mo puedo contactar a mi instructor?",
                "¬øD√≥nde encuentro el reglamento del aprendiz?"
            ],
            'instructores': [
                "¬øC√≥mo tomo asistencia de mis estudiantes?",
                "¬øC√≥mo creo un horario de clases?",
                "¬øC√≥mo eval√∫o el desempe√±o de un aprendiz?",
                "¬øD√≥nde veo los reportes de asistencia?",
                "¬øC√≥mo programo un ambiente de formaci√≥n?",
                "¬øC√≥mo gestiono las evaluaciones?",
                "¬øD√≥nde reporto incidencias disciplinarias?",
                "¬øC√≥mo accedo al comit√© acad√©mico?",
                "¬øC√≥mo configuro notificaciones?",
                "¬øD√≥nde est√°n las gu√≠as pedag√≥gicas?"
            ],
            'administrativos': [
                "¬øC√≥mo genero reportes de asistencia?",
                "¬øC√≥mo gestiono usuarios del sistema?",
                "¬øD√≥nde veo las estad√≠sticas generales?",
                "¬øC√≥mo configuro el sistema de evaluaciones?",
                "¬øC√≥mo administro los horarios institucionales?",
                "¬øD√≥nde est√°n los logs del sistema?",
                "¬øC√≥mo gestiono los comit√©s acad√©micos?",
                "¬øC√≥mo configuro las integraciones?",
                "¬øD√≥nde veo el estado de los servicios?",
                "¬øC√≥mo hago backup de la informaci√≥n?"
            ]
        }
    
    def load_knowledge_base(self, knowledge_file: str) -> None:
        """Cargar la base de conocimiento."""
        
        try:
            with open(knowledge_file, 'r', encoding='utf-8') as f:
                self.knowledge_items = json.load(f)
            print(f"üìö Base de conocimiento cargada: {len(self.knowledge_items)} items")
        except Exception as e:
            print(f"‚ùå Error cargando base de conocimiento: {e}")
            self.knowledge_items = []
    
    def search_knowledge(self, query: str, user_role: str = 'general') -> List[Dict[str, Any]]:
        """Buscar en la base de conocimiento."""
        
        query_lower = query.lower()
        results = []
        
        # Palabras clave de la consulta
        query_words = set(re.findall(r'\w+', query_lower))
        
        for item in self.knowledge_items:
            score = 0
            
            # Filtrar por audiencia si es espec√≠fica
            if user_role != 'general' and item['target_audience'] not in ['general', user_role]:
                continue
            
            # Puntaje por t√≠tulo
            title_words = set(re.findall(r'\w+', item['title'].lower()))
            title_matches = len(query_words.intersection(title_words))
            score += title_matches * 3
            
            # Puntaje por contenido
            content_words = set(re.findall(r'\w+', item['content'].lower()))
            content_matches = len(query_words.intersection(content_words))
            score += content_matches
            
            # Puntaje por tags
            tag_words = set()
            for tag in item['tags']:
                tag_words.update(re.findall(r'\w+', tag.lower()))
            tag_matches = len(query_words.intersection(tag_words))
            score += tag_matches * 2
            
            # Bonus por palabras clave espec√≠ficas
            if any(word in item['content'].lower() for word in ['c√≥mo', 'tutorial', 'gu√≠a', 'paso']):
                score += 1
            
            if score > 0:
                results.append({
                    'item': item,
                    'score': score,
                    'relevance_reason': self._explain_relevance(query_words, item)
                })
        
        # Ordenar por puntaje
        results.sort(key=lambda x: x['score'], reverse=True)
        
        return results[:5]  # Top 5 resultados
    
    def _explain_relevance(self, query_words: set, item: Dict[str, Any]) -> str:
        """Explicar por qu√© un item es relevante."""
        
        reasons = []
        
        # Comprobar coincidencias en t√≠tulo
        title_words = set(re.findall(r'\w+', item['title'].lower()))
        title_matches = query_words.intersection(title_words)
        if title_matches:
            reasons.append(f"t√≠tulo contiene: {', '.join(title_matches)}")
        
        # Comprobar coincidencias en tags
        tag_words = set()
        for tag in item['tags']:
            tag_words.update(re.findall(r'\w+', tag.lower()))
        tag_matches = query_words.intersection(tag_words)
        if tag_matches:
            reasons.append(f"tags relacionados: {', '.join(tag_matches)}")
        
        # Comprobar tipo de contenido
        if item['content_type'] in ['tutorial', 'guide', 'procedure']:
            reasons.append(f"es un {item['content_type']}")
        
        return "; ".join(reasons) if reasons else "contenido relacionado"
    
    def simulate_support_session(self, user_role: str) -> None:
        """Simular una sesi√≥n de soporte para un tipo de usuario."""
        
        print(f"\nüé≠ SIMULACI√ìN DE SOPORTE - ROL: {user_role.upper()}")
        print("="*60)
        
        if user_role not in self.sample_queries:
            print(f"‚ùå Rol '{user_role}' no reconocido")
            return
        
        queries = self.sample_queries[user_role]
        
        for i, query in enumerate(queries[:5]):  # Solo 5 consultas por demo
            print(f"\nüìù Consulta {i+1}: \"{query}\"")
            print("-" * 40)
            
            results = self.search_knowledge(query, user_role)
            
            if not results:
                print("‚ùå No se encontraron resultados relevantes")
                continue
            
            print(f"‚úÖ Encontrados {len(results)} resultados:")
            
            for j, result in enumerate(results[:3]):  # Top 3
                item = result['item']
                score = result['score']
                reason = result['relevance_reason']
                
                print(f"\n   {j+1}. {item['title']}")
                print(f"      üìä Relevancia: {score} puntos ({reason})")
                print(f"      üìÇ Tipo: {item['content_type']} | Categor√≠a: {item['category']}")
                print(f"      üë• Audiencia: {item['target_audience']}")
                
                # Mostrar fragmento del contenido
                content_preview = item['content'][:200].replace('\n', ' ')
                print(f"      üìÑ Contenido: {content_preview}...")
                
                if j == 0:  # Mostrar tags solo del primer resultado
                    print(f"      üè∑Ô∏è  Tags: {', '.join(item['tags'])}")
    
    def generate_support_coverage_report(self) -> Dict[str, Any]:
        """Generar reporte de cobertura de soporte."""
        
        coverage = {
            'total_items': len(self.knowledge_items),
            'by_audience': {},
            'by_content_type': {},
            'by_category': {},
            'top_tags': {},
            'coverage_analysis': {}
        }
        
        # Estad√≠sticas b√°sicas
        for item in self.knowledge_items:
            # Por audiencia
            aud = item['target_audience']
            coverage['by_audience'][aud] = coverage['by_audience'].get(aud, 0) + 1
            
            # Por tipo de contenido
            ct = item['content_type']
            coverage['by_content_type'][ct] = coverage['by_content_type'].get(ct, 0) + 1
            
            # Por categor√≠a
            cat = item['category']
            coverage['by_category'][cat] = coverage['by_category'].get(cat, 0) + 1
            
            # Tags m√°s frecuentes
            for tag in item['tags']:
                coverage['top_tags'][tag] = coverage['top_tags'].get(tag, 0) + 1
        
        # An√°lisis de cobertura por √°rea funcional
        functional_areas = {
            'autenticacion': ['login', 'sesi√≥n', 'contrase√±a', 'password', 'autenticacion'],
            'asistencia': ['asistencia', 'presente', 'ausente', 'tardanza'],
            'evaluacion': ['evaluaci√≥n', 'calificaci√≥n', 'nota', 'evaluacion'],
            'horarios': ['horario', 'clase', 'ambiente', 'programaci√≥n'],
            'usuarios': ['usuario', 'perfil', 'rol', 'permiso'],
            'reportes': ['reporte', 'estad√≠stica', 'dashboard', 'gr√°fico'],
            'comites': ['comit√©', 'acad√©mico', 'disciplinario'],
            'notificaciones': ['notificaci√≥n', 'alerta', 'mensaje', 'email']
        }
        
        for area, keywords in functional_areas.items():
            count = 0
            for item in self.knowledge_items:
                content_lower = item['content'].lower()
                if any(keyword in content_lower for keyword in keywords):
                    count += 1
            coverage['coverage_analysis'][area] = count
        
        return coverage
    
    def demonstrate_ai_integration(self) -> None:
        """Demostrar c√≥mo se integrar√≠a con el AIService."""
        
        print(f"\nü§ñ DEMOSTRACI√ìN DE INTEGRACI√ìN CON AISERVICE")
        print("="*60)
        
        # Consultas complejas que requieren IA
        complex_queries = [
            "Ay√∫dame a entender el proceso completo de evaluaci√≥n de proyectos",
            "¬øCu√°l es la diferencia entre una falta leve y una grave?",
            "Expl√≠came paso a paso c√≥mo gestionar un comit√© acad√©mico",
            "¬øQu√© debo hacer si un aprendiz tiene muchas ausencias?"
        ]
        
        for query in complex_queries:
            print(f"\n‚ùì Consulta compleja: \"{query}\"")
            print("-" * 50)
            
            # Simular b√∫squeda en KB
            results = self.search_knowledge(query, 'general')
            
            print(f"üìö Contexto desde KB: {len(results)} documentos relevantes")
            
            if results:
                # Simular lo que har√≠a el AIService
                context_docs = []
                for result in results[:3]:
                    context_docs.append({
                        'title': result['item']['title'],
                        'content_snippet': result['item']['content'][:300],
                        'relevance': result['score']
                    })
                
                print("üîÑ El AIService procesar√≠a:")
                print("   1. Consulta del usuario")
                print("   2. Contexto relevante desde KB")
                print("   3. Generar√≠a respuesta personalizada")
                
                print(f"\nüìÑ Documentos de contexto utilizados:")
                for i, doc in enumerate(context_docs):
                    print(f"   {i+1}. {doc['title']} (relevancia: {doc['relevance']})")
                
                print(f"\n‚ú® Respuesta AI simulada:")
                print(f"   \"Bas√°ndome en la documentaci√≥n de SICORA, te explico...")
                print(f"   [Respuesta personalizada basada en {len(context_docs)} documentos]\"")
            else:
                print("‚ö†Ô∏è  Sin contexto suficiente - AIService responder√≠a con conocimiento general")


def main():
    """Funci√≥n principal."""
    
    print("üéØ SIMULADOR DE CONSULTAS DE SOPORTE - KBSERVICE")
    print("="*70)
    
    # Verificar archivos
    kb_file = 'knowledge_base_content.json'
    if not Path(kb_file).exists():
        print(f"‚ùå No se encontr√≥ {kb_file}")
        print("üí° Ejecuta primero: python extract_knowledge.py")
        return
    
    # Crear simulador
    simulator = SupportQuerySimulator(kb_file)
    
    if not simulator.knowledge_items:
        print("‚ùå No se pudo cargar la base de conocimiento")
        return
    
    # Simular consultas por tipo de usuario
    for user_role in ['aprendices', 'instructores', 'administrativos']:
        simulator.simulate_support_session(user_role)
    
    # Demostrar integraci√≥n con AI
    simulator.demonstrate_ai_integration()
    
    # Generar reporte de cobertura
    print(f"\nüìä REPORTE DE COBERTURA DE SOPORTE")
    print("="*50)
    
    coverage = simulator.generate_support_coverage_report()
    
    print(f"üìö Total de items en KB: {coverage['total_items']}")
    
    print(f"\nüë• Cobertura por audiencia:")
    for aud, count in coverage['by_audience'].items():
        percentage = (count / coverage['total_items']) * 100
        print(f"   {aud}: {count} items ({percentage:.1f}%)")
    
    print(f"\nüìÑ Cobertura por tipo de contenido:")
    for ct, count in coverage['by_content_type'].items():
        print(f"   {ct}: {count} items")
    
    print(f"\nüîß Cobertura por √°rea funcional:")
    for area, count in coverage['coverage_analysis'].items():
        print(f"   {area}: {count} documentos")
    
    print(f"\nüè∑Ô∏è  Tags m√°s frecuentes:")
    top_tags = sorted(coverage['top_tags'].items(), key=lambda x: x[1], reverse=True)[:10]
    for tag, count in top_tags:
        print(f"   {tag}: {count} veces")
    
    print(f"\nüéâ RESUMEN FINAL")
    print("="*30)
    print(f"‚úÖ KBService est√° listo para dar soporte completo sobre SICORA")
    print(f"üìö {coverage['total_items']} documentos de soporte disponibles")
    print(f"üë• Cobertura para todos los roles de usuario")
    print(f"ü§ñ Listo para integraci√≥n con AIService")
    print(f"üîç B√∫squeda inteligente implementada")
    print(f"üìà An√°lisis de relevancia autom√°tico")


if __name__ == "__main__":
    main()
