package repositories

import (
	"context"
	"fmt"
	"time"

	"github.com/google/uuid"
	"gorm.io/gorm"

	"github.com/sicora-dev/evalinservice/internal/domain/entities"
	"github.com/sicora-dev/evalinservice/internal/domain/repositories"
	"github.com/sicora-dev/evalinservice/internal/domain/valueobjects"
	"github.com/sicora-dev/evalinservice/internal/infrastructure/database/mappers"
	"github.com/sicora-dev/evalinservice/internal/infrastructure/database/models"
)

type reportRepositoryImpl struct {
	db     *gorm.DB
	mapper *mappers.ReportMapper
}

func NewReportRepository(db *gorm.DB) repositories.ReportRepository {
	return &reportRepositoryImpl{
		db:     db,
		mapper: mappers.NewReportMapper(),
	}
}

func (r *reportRepositoryImpl) Create(ctx context.Context, report *entities.Report) error {
	model := r.mapper.ToModel(report)
	if err := r.db.WithContext(ctx).Create(model).Error; err != nil {
		return fmt.Errorf("failed to create report: %w", err)
	}
	return nil
}

func (r *reportRepositoryImpl) GetByID(ctx context.Context, id uuid.UUID) (*entities.Report, error) {
	var model models.Report
	if err := r.db.WithContext(ctx).First(&model, "id = ?", id).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, nil
		}
		return nil, fmt.Errorf("failed to get report by ID: %w", err)
	}
	return r.mapper.ToEntity(&model), nil
}

func (r *reportRepositoryImpl) Update(ctx context.Context, report *entities.Report) error {
	model := r.mapper.ToModel(report)
	if err := r.db.WithContext(ctx).Save(model).Error; err != nil {
		return fmt.Errorf("failed to update report: %w", err)
	}
	return nil
}

func (r *reportRepositoryImpl) Delete(ctx context.Context, id uuid.UUID) error {
	if err := r.db.WithContext(ctx).Delete(&models.Report{}, "id = ?", id).Error; err != nil {
		return fmt.Errorf("failed to delete report: %w", err)
	}
	return nil
}

func (r *reportRepositoryImpl) GetByPeriod(ctx context.Context, periodID uuid.UUID) ([]*entities.Report, error) {
	var reports []models.Report
	if err := r.db.WithContext(ctx).Where("period_id = ?", periodID).
		Order("created_at DESC").Find(&reports).Error; err != nil {
		return nil, fmt.Errorf("failed to get reports by period: %w", err)
	}

	result := make([]*entities.Report, len(reports))
	for i, model := range reports {
		result[i] = r.mapper.ToEntity(&model)
	}
	return result, nil
}

// GetByPeriodID es un alias para GetByPeriod (para compatibilidad con interface)
func (r *reportRepositoryImpl) GetByPeriodID(ctx context.Context, periodID uuid.UUID) ([]*entities.Report, error) {
	return r.GetByPeriod(ctx, periodID)
}

func (r *reportRepositoryImpl) GetByType(ctx context.Context, reportType valueobjects.ReportType) ([]*entities.Report, error) {
	var reports []models.Report
	if err := r.db.WithContext(ctx).Where("type = ?", string(reportType)).
		Order("created_at DESC").Find(&reports).Error; err != nil {
		return nil, fmt.Errorf("failed to get reports by type: %w", err)
	}

	result := make([]*entities.Report, len(reports))
	for i, model := range reports {
		result[i] = r.mapper.ToEntity(&model)
	}
	return result, nil
}

func (r *reportRepositoryImpl) GetByGeneratedBy(ctx context.Context, userID uuid.UUID) ([]*entities.Report, error) {
	var reports []models.Report
	if err := r.db.WithContext(ctx).Where("generated_by = ?", userID).
		Order("created_at DESC").Find(&reports).Error; err != nil {
		return nil, fmt.Errorf("failed to get reports by generated by: %w", err)
	}

	result := make([]*entities.Report, len(reports))
	for i, model := range reports {
		result[i] = r.mapper.ToEntity(&model)
	}
	return result, nil
}

func (r *reportRepositoryImpl) GetRecentReports(ctx context.Context, limit int) ([]*entities.Report, error) {
	var reports []models.Report
	query := r.db.WithContext(ctx).Order("created_at DESC")

	if limit > 0 {
		query = query.Limit(limit)
	}

	if err := query.Find(&reports).Error; err != nil {
		return nil, fmt.Errorf("failed to get recent reports: %w", err)
	}

	result := make([]*entities.Report, len(reports))
	for i, model := range reports {
		result[i] = r.mapper.ToEntity(&model)
	}
	return result, nil
}

func (r *reportRepositoryImpl) GetReportsByDateRange(ctx context.Context, startDate, endDate time.Time) ([]*entities.Report, error) {
	var reports []models.Report
	if err := r.db.WithContext(ctx).
		Where("created_at BETWEEN ? AND ?", startDate, endDate).
		Order("created_at DESC").Find(&reports).Error; err != nil {
		return nil, fmt.Errorf("failed to get reports by date range: %w", err)
	}

	result := make([]*entities.Report, len(reports))
	for i, model := range reports {
		result[i] = r.mapper.ToEntity(&model)
	}
	return result, nil
}

func (r *reportRepositoryImpl) GetPendingReports(ctx context.Context) ([]*entities.Report, error) {
	var reports []models.Report
	if err := r.db.WithContext(ctx).Where("status = ?", "PENDING").
		Order("created_at DESC").Find(&reports).Error; err != nil {
		return nil, fmt.Errorf("failed to get pending reports: %w", err)
	}

	result := make([]*entities.Report, len(reports))
	for i, model := range reports {
		result[i] = r.mapper.ToEntity(&model)
	}
	return result, nil
}

func (r *reportRepositoryImpl) MarkAsProcessing(ctx context.Context, id uuid.UUID) error {
	if err := r.db.WithContext(ctx).Model(&models.Report{}).
		Where("id = ?", id).Update("status", "PROCESSING").Error; err != nil {
		return fmt.Errorf("failed to mark report as processing: %w", err)
	}
	return nil
}

func (r *reportRepositoryImpl) MarkAsCompleted(ctx context.Context, id uuid.UUID, filePath string) error {
	updates := map[string]interface{}{
		"status":    "COMPLETED",
		"file_path": filePath,
	}

	if err := r.db.WithContext(ctx).Model(&models.Report{}).
		Where("id = ?", id).Updates(updates).Error; err != nil {
		return fmt.Errorf("failed to mark report as completed: %w", err)
	}
	return nil
}

func (r *reportRepositoryImpl) MarkAsFailed(ctx context.Context, id uuid.UUID, errorMsg string) error {
	updates := map[string]interface{}{
		"status":     "FAILED",
		"error_info": errorMsg,
	}

	if err := r.db.WithContext(ctx).Model(&models.Report{}).
		Where("id = ?", id).Updates(updates).Error; err != nil {
		return fmt.Errorf("failed to mark report as failed: %w", err)
	}
	return nil
}

func (r *reportRepositoryImpl) CountByStatus(ctx context.Context, status valueobjects.ReportStatus) (int64, error) {
	var count int64
	if err := r.db.WithContext(ctx).Model(&models.Report{}).
		Where("status = ?", string(status)).
		Count(&count).Error; err != nil {
		return 0, fmt.Errorf("failed to count reports by status: %w", err)
	}
	return count, nil
}

func (r *reportRepositoryImpl) GetByStatus(ctx context.Context, status valueobjects.ReportStatus) ([]*entities.Report, error) {
	var reports []models.Report
	if err := r.db.WithContext(ctx).Where("status = ?", string(status)).
		Order("created_at DESC").Find(&reports).Error; err != nil {
		return nil, fmt.Errorf("failed to get reports by status: %w", err)
	}

	result := make([]*entities.Report, len(reports))
	for i, model := range reports {
		result[i] = r.mapper.ToEntity(&model)
	}
	return result, nil
}
