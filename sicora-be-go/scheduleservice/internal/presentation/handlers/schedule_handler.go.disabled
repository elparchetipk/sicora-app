package handlers

import (
	"net/http"
	"strconv"

	"scheduleservice/internal/application/dtos"
	"scheduleservice/internal/application/usecases"
	"scheduleservice/internal/domain/repositories"
	"scheduleservice/internal/presentation/middleware"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
)

// ScheduleHandler maneja las operaciones HTTP para horarios
type ScheduleHandler struct {
	scheduleUseCase *usecases.ScheduleUseCase
}

// NewScheduleHandler crea una nueva instancia del handler
func NewScheduleHandler(scheduleUseCase *usecases.ScheduleUseCase) *ScheduleHandler {
	return &ScheduleHandler{
		scheduleUseCase: scheduleUseCase,
	}
}

// CreateSchedule crea un nuevo horario
// @Summary Crear horario
// @Description Crea un nuevo horario académico
// @Tags schedules
// @Accept json
// @Produce json
// @Param schedule body dtos.CreateScheduleDTO true "Datos del horario"
// @Success 201 {object} dtos.ScheduleResponseDTO
// @Failure 400 {object} map[string]interface{}
// @Failure 401 {object} map[string]interface{}
// @Failure 403 {object} map[string]interface{}
// @Failure 500 {object} map[string]interface{}
// @Security BearerAuth
// @Router /schedules [post]
func (h *ScheduleHandler) CreateSchedule(c *gin.Context) {
	var dto dtos.CreateScheduleDTO

	if err := c.ShouldBindJSON(&dto); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error":   "Invalid request data",
			"message": err.Error(),
		})
		return
	}

	// Obtener userID del contexto
	userID, err := middleware.GetUserID(c)
	if err != nil {
		c.JSON(http.StatusUnauthorized, gin.H{
			"error":   "Authentication required",
			"message": err.Error(),
		})
		return
	}

	schedule, err := h.scheduleUseCase.CreateSchedule(c.Request.Context(), &dto, userID)
	if err != nil {
		if err.Error() == "instructor conflict" || err.Error() == "venue conflict" || err.Error() == "group conflict" {
			c.JSON(http.StatusConflict, gin.H{
				"error":   "Schedule conflict",
				"message": err.Error(),
			})
			return
		}

		c.JSON(http.StatusInternalServerError, gin.H{
			"error":   "Failed to create schedule",
			"message": err.Error(),
		})
		return
	}

	c.JSON(http.StatusCreated, gin.H{
		"data":    schedule,
		"message": "Schedule created successfully",
	})
}

// GetSchedule obtiene un horario por ID
// @Summary Obtener horario por ID
// @Description Obtiene los detalles de un horario específico
// @Tags schedules
// @Accept json
// @Produce json
// @Param id path string true "ID del horario"
// @Success 200 {object} dtos.ScheduleResponseDTO
// @Failure 400 {object} map[string]interface{}
// @Failure 401 {object} map[string]interface{}
// @Failure 404 {object} map[string]interface{}
// @Failure 500 {object} map[string]interface{}
// @Security BearerAuth
// @Router /schedules/{id} [get]
func (h *ScheduleHandler) GetSchedule(c *gin.Context) {
	idParam := c.Param("id")
	id, err := uuid.Parse(idParam)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error":   "Invalid schedule ID",
			"message": "Schedule ID must be a valid UUID",
		})
		return
	}

	schedule, err := h.scheduleUseCase.GetSchedule(c.Request.Context(), id)
	if err != nil {
		if err.Error() == "schedule not found" {
			c.JSON(http.StatusNotFound, gin.H{
				"error":   "Schedule not found",
				"message": "The requested schedule does not exist",
			})
			return
		}

		c.JSON(http.StatusInternalServerError, gin.H{
			"error":   "Failed to get schedule",
			"message": err.Error(),
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"data": schedule,
	})
}

// ListSchedules lista horarios con filtros
// @Summary Listar horarios
// @Description Lista horarios con filtros opcionales y paginación
// @Tags schedules
// @Accept json
// @Produce json
// @Param page query int false "Número de página" default(1)
// @Param page_size query int false "Tamaño de página" default(20)
// @Param search query string false "Búsqueda por materia"
// @Param instructor_id query string false "ID del instructor"
// @Param academic_group_id query string false "ID del grupo académico"
// @Param venue_id query string false "ID del ambiente"
// @Param day_of_week query int false "Día de la semana (1-7)"
// @Param start_date query string false "Fecha de inicio (YYYY-MM-DD)"
// @Param end_date query string false "Fecha de fin (YYYY-MM-DD)"
// @Param status query string false "Estado del horario"
// @Param is_active query bool false "Horarios activos"
// @Success 200 {object} dtos.PaginatedScheduleResponseDTO
// @Failure 400 {object} map[string]interface{}
// @Failure 401 {object} map[string]interface{}
// @Failure 500 {object} map[string]interface{}
// @Security BearerAuth
// @Router /schedules [get]
func (h *ScheduleHandler) ListSchedules(c *gin.Context) {
	// Parse query parameters
	filter, err := h.parseScheduleFilter(c)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error":   "Invalid query parameters",
			"message": err.Error(),
		})
		return
	}

	// Aplicar filtros por rol si es necesario
	userRole, _ := middleware.GetUserRole(c)
	userID, _ := middleware.GetUserID(c)

	// Si no es admin, filtrar por rol
	if userRole != "admin" {
		if userRole == "instructor" {
			filter.InstructorID = &userID
		} else if userRole == "aprendiz" {
			fichaID := middleware.GetUserFichaID(c)
			if fichaID != nil {
				// TODO: Obtener academic_group_id basado en ficha_id
				// Por ahora permitimos ver todos los horarios
			}
		}
	}

	schedules, total, err := h.scheduleUseCase.ListSchedules(c.Request.Context(), filter)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error":   "Failed to list schedules",
			"message": err.Error(),
		})
		return
	}

	response := &dtos.PaginatedScheduleResponseDTO{
		Data: schedules,
		Pagination: dtos.PaginationDTO{
			Page:       filter.Page,
			PageSize:   filter.PageSize,
			Total:      total,
			TotalPages: (total + int64(filter.PageSize) - 1) / int64(filter.PageSize),
		},
	}

	c.JSON(http.StatusOK, response)
}

// UpdateSchedule actualiza un horario
// @Summary Actualizar horario
// @Description Actualiza un horario existente
// @Tags schedules
// @Accept json
// @Produce json
// @Param id path string true "ID del horario"
// @Param schedule body dtos.UpdateScheduleDTO true "Datos actualizados del horario"
// @Success 200 {object} dtos.ScheduleResponseDTO
// @Failure 400 {object} map[string]interface{}
// @Failure 401 {object} map[string]interface{}
// @Failure 403 {object} map[string]interface{}
// @Failure 404 {object} map[string]interface{}
// @Failure 409 {object} map[string]interface{}
// @Failure 500 {object} map[string]interface{}
// @Security BearerAuth
// @Router /schedules/{id} [put]
func (h *ScheduleHandler) UpdateSchedule(c *gin.Context) {
	idParam := c.Param("id")
	id, err := uuid.Parse(idParam)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error":   "Invalid schedule ID",
			"message": "Schedule ID must be a valid UUID",
		})
		return
	}

	var dto dtos.UpdateScheduleDTO
	if err := c.ShouldBindJSON(&dto); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error":   "Invalid request data",
			"message": err.Error(),
		})
		return
	}

	userID, err := middleware.GetUserID(c)
	if err != nil {
		c.JSON(http.StatusUnauthorized, gin.H{
			"error":   "Authentication required",
			"message": err.Error(),
		})
		return
	}

	schedule, err := h.scheduleUseCase.UpdateSchedule(c.Request.Context(), id, &dto, userID)
	if err != nil {
		if err.Error() == "schedule not found" {
			c.JSON(http.StatusNotFound, gin.H{
				"error":   "Schedule not found",
				"message": "The requested schedule does not exist",
			})
			return
		}

		if err.Error() == "instructor conflict" || err.Error() == "venue conflict" || err.Error() == "group conflict" {
			c.JSON(http.StatusConflict, gin.H{
				"error":   "Schedule conflict",
				"message": err.Error(),
			})
			return
		}

		c.JSON(http.StatusInternalServerError, gin.H{
			"error":   "Failed to update schedule",
			"message": err.Error(),
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"data":    schedule,
		"message": "Schedule updated successfully",
	})
}

// DeleteSchedule elimina un horario
// @Summary Eliminar horario
// @Description Elimina un horario existente
// @Tags schedules
// @Accept json
// @Produce json
// @Param id path string true "ID del horario"
// @Success 200 {object} map[string]interface{}
// @Failure 400 {object} map[string]interface{}
// @Failure 401 {object} map[string]interface{}
// @Failure 403 {object} map[string]interface{}
// @Failure 404 {object} map[string]interface{}
// @Failure 500 {object} map[string]interface{}
// @Security BearerAuth
// @Router /schedules/{id} [delete]
func (h *ScheduleHandler) DeleteSchedule(c *gin.Context) {
	idParam := c.Param("id")
	id, err := uuid.Parse(idParam)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error":   "Invalid schedule ID",
			"message": "Schedule ID must be a valid UUID",
		})
		return
	}

	userID, err := middleware.GetUserID(c)
	if err != nil {
		c.JSON(http.StatusUnauthorized, gin.H{
			"error":   "Authentication required",
			"message": err.Error(),
		})
		return
	}

	err = h.scheduleUseCase.DeleteSchedule(c.Request.Context(), id, userID)
	if err != nil {
		if err.Error() == "schedule not found" {
			c.JSON(http.StatusNotFound, gin.H{
				"error":   "Schedule not found",
				"message": "The requested schedule does not exist",
			})
			return
		}

		c.JSON(http.StatusInternalServerError, gin.H{
			"error":   "Failed to delete schedule",
			"message": err.Error(),
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message": "Schedule deleted successfully",
	})
}

// Helper methods

func (h *ScheduleHandler) parseScheduleFilter(c *gin.Context) (*repositories.ScheduleFilter, error) {
	filter := &repositories.ScheduleFilter{}

	// Pagination
	if page := c.Query("page"); page != "" {
		if p, err := strconv.Atoi(page); err == nil && p > 0 {
			filter.Page = p
		} else {
			filter.Page = 1
		}
	} else {
		filter.Page = 1
	}

	if pageSize := c.Query("page_size"); pageSize != "" {
		if ps, err := strconv.Atoi(pageSize); err == nil && ps > 0 && ps <= 100 {
			filter.PageSize = ps
		} else {
			filter.PageSize = 20
		}
	} else {
		filter.PageSize = 20
	}

	// Search
	filter.Search = c.Query("search")

	// Filters
	if instructorID := c.Query("instructor_id"); instructorID != "" {
		if id, err := uuid.Parse(instructorID); err == nil {
			filter.InstructorID = &id
		}
	}

	if groupID := c.Query("academic_group_id"); groupID != "" {
		if id, err := uuid.Parse(groupID); err == nil {
			filter.AcademicGroupID = &id
		}
	}

	if venueID := c.Query("venue_id"); venueID != "" {
		if id, err := uuid.Parse(venueID); err == nil {
			filter.VenueID = &id
		}
	}

	if dayOfWeek := c.Query("day_of_week"); dayOfWeek != "" {
		if dow, err := strconv.Atoi(dayOfWeek); err == nil && dow >= 1 && dow <= 7 {
			filter.DayOfWeek = &dow
		}
	}

	// TODO: Parse start_date and end_date

	filter.Status = c.Query("status")
	filter.Subject = c.Query("subject")
	filter.BlockIdentifier = c.Query("block_identifier")

	if isActive := c.Query("is_active"); isActive != "" {
		if active, err := strconv.ParseBool(isActive); err == nil {
			filter.IsActive = &active
		}
	}

	return filter, nil
}
